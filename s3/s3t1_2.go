/*
https://contest.yandex.ru/contest/23815/run-report/87822354/
-- ПРИНЦИП РАБОТЫ --
Данный алгоритм - реализация модифицированного двоичного поиска.

Алгоритм принимает на вход слайс arr и искомый элемент k.
Он ищет k в слайсе и возвращает индекс элемента, если он найден, или -1, если элемент не найден.

Алгоритм использует переменные left(начальная граница слайса) и right(конечная граница слайса).

Затем выполняется цикл, пока left меньше или равно right.
Внутри цикла вычисляется средний индекс mid с помощью формулы (left + right) / 2.
Затем происходит сравнение элемента arr[mid] с искомым элементом k:
	Если arr[mid] равен k, то функция возвращает mid, так как элемент найден.

	Если arr[left] меньше или равен arr[mid], это означает, что левая половина слайса отсортирована.
В этом случае проверяется, находится ли k в пределах отсортированного участка. Если k >= arr[left] и < arr[mid], то right = mid - 1, чтобы сузить область поиска до левой половины.
В противном случае, left =  mid + 1, чтобы сузить область поиска до правой половины.

	Если arr[left] > arr[mid], это означает, что правая половина массива отсортирована.
В этом случае проверяется, находится ли k в пределах отсортированного участка. Если k > arr[mid] и <= arr[right], то left = mid + 1, чтобы сузить область поиска до правой половины.
В противном случае, right = mid - 1, чтобы сузить область поиска до левой половины.

	Если ни одно из условий не выполняется и цикл завершается, и это означает, что элемент k не найден в массиве - функция возвращает -1.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
В худшем случае алгоритм имеет логарифмическую сложность O(log n), где n - размер массива.
Это связано с тем, что на каждой итерации цикла область поиска сужается в два раза.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Пространственная сложность будет равна 0(n), n - размер входного слайса arr.
Все операции производятся над входным слайсом без копирования, дополнительно используются временные переменные left, right и mid, но их размер постоянен.
*/

package main

func brokenSearch(arr []int, k int) int {
	left, right := 0, len(arr)-1

	for left <= right {
		mid := (left + right) / 2

		if arr[mid] == k {
			return mid
		}

		if arr[left] <= arr[mid] {
			if k >= arr[left] && k < arr[mid] {
				right = mid - 1
			} else {
				left = mid + 1
			}
		} else {
			if k > arr[mid] && k <= arr[right] {
				left = mid + 1
			} else {
				right = mid - 1
			}
		}
	}

	return -1
}
